<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[std::forward详解]]></title>
    <url>%2Fc%2B%2B%2Fforward%2F</url>
    <content type="text"><![CDATA[std::forward比std::move逻辑略复杂，std::move是无条件把参数转换为右值，而std::forward在特定情况下才会这样做：仅当参数是用右值初始化时，才会把它转换为右值。使用std::forward来转发参数一般被称为完美转发(也叫精确传递)。 完美转发参数的属性通常包括：左值／右值和 const/non-const。 完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变。在泛型函数中，这样的需求非常普遍。 std::forward的大致实现如下： 12345template&lt;typename T&gt; // 在命名空间std中T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; param)&#123; return static_cast&lt;T&amp;&amp;&gt;(param);&#125; 一个模板函数接受全局引用，然后用std::forward把参数传递给另一个函数。 示例分析 如果传递给函数f的是个左值的Widget，T会被推断为Widget&amp;： 123456789101112131415Widget&amp; &amp;&amp; forward(typename remove_reference&lt;Widget&amp;&gt;::type&amp; param)&#123; return static_cast&lt;Widget&amp; &amp;&amp;&gt;(param);&#125;// remove_reference&lt;Widget&amp;&gt;::type产生的是WidgetWidget&amp; &amp;&amp; forward(Widget&amp; param)&#123; return static_cast&lt;Widget&amp; &amp;&amp;&gt;(param);&#125;// 发生引用折叠，最终版本的std::forward：Widget&amp; forward(Widget&amp; param)&#123; return static_cast&lt;Widget&amp;&gt;(param); &#125;// 这次转换没造成任何影响 假设传递给函数f的是个右值的Widget,函数f的类型参数T会被推断为Widget 12345678910Widget&amp;&amp; forward(typename remove_reference&lt;Widget&gt;::type&amp; param)&#123; return static_cast&lt;Widget&amp;&amp;&gt;(param);&#125;// std::remove_reference会产生原来的类型（Widget）Widget&amp;&amp; forward(Widget&amp; param)&#123; return static_cast&lt;Widget&amp;&amp;&gt;(param);&#125;// 不存在引用折叠，这就是最终版本 由函数返回的右值引用被定义为右值，在这种情况下，std::forward会把f的参数fParam（一个左值）转换成一个右值 是否可以摒弃std::move，只是用std::forward？从纯粹的技术角度看，答案是可以的：std::forward可以应付所有场景，std::move不是必须的。 注意事项typedef得到的，可能并不是你想要的类型,例如：12345678template&lt;typename T&gt;class Widget &#123;public: typedef T&amp;&amp; RvalueRefToT; ...&#125;;Widget&lt;int&amp;&gt; w;// typedef int&amp; &amp;&amp; RvalueRefToT; --引用折叠--&gt;typedef int&amp; RvalueRefToT; 避免对通用引用重载我认为这里应当成为特化：当一个模板实例化函数和一个非模板函数（即，一个普通函数）匹配度一样时，优先使用普通函数。在相同的签名下，拷贝构造（普通函数）胜过实例化模板函数。 一个例子：12345678910111213141516template&lt;typename T&gt;void add(T&amp;&amp; rhs) &#123; // ... do something std::string(rhs);&#125;void add(int i) &#123; // ..&#125;// 以下：add&lt;std::string&gt;("hello world"); // ok ！int a = 1;add&lt;std::string&gt;(a); // okshort b = 2;add&lt;std::string&gt;(b); // error,试图构造std::string 接受通用引用作为参数的函数是C++最贪婪的函数，它们可以为几乎所有类型的参数实例化，从而创建的精确匹配。这就是为什么结合重载和通用引用几乎总是个糟糕的想法：通用引用重载吸收的参数类型远多于开发者的期望。 对右值引用使用std::move，对通用引用使用std::forward右值引用：Weight&amp;&amp; ，类型确定，通用引用：typename &amp;&amp;，可能会被推导成左值 如果确定是个右值引用，那么使用std::move处理它，name(std::move(rhs.name); 如果它有可能是个右值引用，那么可以使用std::forward转发它，name = std::forward&lt;T&gt;(newName); 对右值引用使用std::forward会表现出正确的行为，但是源代码会是冗长的、易错的、不符合语言习惯的，因此你应该避免对右值引用使用std::forward。 不要对T &amp;&amp;使用std::move，因为很可能导致传进去的左值丢失。 不要用左值和右值重载：只有通用引用才是正确的方式123456789class Widget &#123;public: void setName(const std::string&amp; newName) // 由const左值设置 &#123; name = newName; &#125; void setName(std::string&amp;&amp; newName) // 由右值设置 &#123; name = std::move(newName); &#125; // ...&#125;; 这种写法是没有问题的，左值由拷贝构造函数执行；右值由移动赋值构造函数执行。但是重载代价比较大，合适的写法是这样的。123456class Widget &#123;public:void setName(T&amp;&amp; newName) // 由右值设置 &#123; name = std::forward&lt;std::string&gt;(newName); &#125; // ...&#125;; 安全的使用std::move和std::forward123456789template&lt;typename T&gt;void setSignText(T&amp;&amp; text) // text是个通用引用&#123; sign.setText(text); // 使用text，但不修改它 auto now = std::chrono::system_clock::now(); // 获取当前时间 signHistory.add(now, std::forward&lt;T&gt;(text)); // 有条件地把text转换为右值&#125; 函数返回值不需要std::move在分配给函数返回值的内存中直接构造w，从而避免拷贝局部变量w:return value optimization（RVO）.这个在C++11以前就明文规定的了。因此放心的创建临时变量，返回吧。再通过std::move赋值给另一个它，只调用了一次构造，一次移动构造函数哦。 熟悉替代重载通用引用的方法 通过const T&amp;传递参数可以的。// 一次拷贝构造函数 通过值传递对象， 12explicit Person(std::string n) // 替换 T&amp;&amp; 构造函数 : name(std::move(n)) &#123;&#125; // 使用std::move` 重载多一个参数的版本，避免匹配到通用引用这个写起来比较麻烦。item 27 约束接受通用引用的模板std::enable_if 12345678class Person &#123;public: template&lt;typename T, typename = typename std::enable_if&lt;condition&gt;::type&gt; explicit Person(T&amp;&amp; n); ...&#125;; std::is_same可以用来判断两个类型是不是一样。 std::decay&lt;T&gt;::type用来去掉那些const、volatile、引用。其实，std::decay就像它的名字表示那样，也可以把数组和函数类型转换成指针类型（看条款1），不过对于这里的讨论，std::decay的行为和我描述的一样。 std::is_base_of&lt;T1, T2&gt;::value,当T2是由T1派生而来时，结果为true。上面的那个condition可以确定了，就是!std::is_same&lt;Person, typename std::decay&lt;T&gt;::type&gt;::value. 完美的person转发构造 123456789101112131415161718192021222324252627282930class Person &#123;public: template&lt; typename T, typename = std::enable_if_t&lt; !std::is_base_of&lt;Person, std::decay_t&lt;T&gt;&gt;::value &amp;&amp; !std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;::value &gt; &gt; explicit Person(T&amp;&amp; n) // 接受std::string类型 : name(std::forward&lt;T&gt;(n)) // 和 可以转换为string的参数的构造函数 &#123; // 断言可以从T对象构造一个std::string static_assert( std::is_constructible&lt;std::string, T&gt;::value, "Parameter n can't be used to construct a std::string" ); // ... &#125; explicit Person(int idx) // 接受整型参数的构造函数 : name(nameFromIdx(idx)) &#123; ... &#125; ... // 拷贝和移动构造， 等等 private: std::string name;&#125;; 总结： 设计类的时候如果有动态申请的资源，也应该设计转移构造函数和转移拷贝函数。在设计类库时，还应该考虑 std::move 的使用场景并积极使用它。std::move和std::forward在运行期都没有做任何事情。因为类型在编译期就已经确认，类型转换在编译期就已经完成。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从重构看编程习惯]]></title>
    <url>%2Fc%2B%2B%2Frebuild%2F</url>
    <content type="text"><![CDATA[背景最近两周，应老大的要求完成这样一项工作：有一个巨大的C++项目，接受http请求，然后根据类型字段判断走何种逻辑，打点功能和其他功能逻辑完全无关。我的任务就是把这部分逻辑从当前进程剥离出来，作为一个单独的服务。这里记录一下遇到的坑和一些不好的编码习惯。 如何快速模块拆分重组我想我这次的工作并不能称之为重构，目的很明确：不修改逻辑，把模块独立出来。 一些编译错误不得不说，大部分时间都在编译和修改编译错误。错误不多一般就几种：has not been declared：未定义，使用了没有包含头文件的函数，static变量没有在类外定义。undefined reference to：找不到实现，大部分是给出了头文件而找不到实现。redefinition of...：重定义了，编译器会提示那几处定义了，头文件里如果有定义，那么很容易出现这个问题，我这次没怎么遇到。no such file：头文件找不到，我遇到了很多，因为有些头文件依赖很多东西，而我并不想包含它。事实证明，所有的编译问题都是容易解决的，除非它引入了太多你不想要的东西。 循序渐进我的做法是：完全新建一个目录，写下main函数，然后照着之前的逻辑开始拷贝代码，如果它需要其他头文件，那么将头文件和实现拷过来，进行编译。假如有某个函数的实现和其他模块有太多的牵连，比如头文件里或者源文件里又包含了非常多的其他的头文件，会瞬间导致文件个数暴增，编译变得困难，那么我会选择注释掉这个函数，加上标记方便我回头找到它，用一个其他的值代替它，比如if(afun()) --&gt; if (true)。当然你也可以在它的头文件和源文件中注释掉某些内容使其通过编译。许多代码会像树一样，主流程就是主干，期间会调用许多函数，就像枝干一样，函数调用越深，枝干也就越细越长。我们要做的就是保证主流程每新加一点东西都能通过编译，当枝丫不容易通过编译时就先砍掉一部分。 使用工具保存的进度git是个很适合的工具，你可以发现你改动了那些部分，当新加的内容能通过编译后，别犹豫commit，并写上详细的信息。 拆分文件工作越往后进行我越发现我加入编译的文件越来越多，小而美才是我想要的。我在这里发现了很多奇怪的文件，名字都包含...common...，里面有非常之多的函数，写了一个函数没地方放就放到commonw文件里？我的做法是，头文件里的函数全部保留，但是头文件基本全部注释掉或者改用前置声明。源文件里的函数基本全注释掉，然后编译。编译器会告诉我那些文件我没有定义，这时候把它取消掉注释就好了。 工具公司用的scons，用不太习惯，我选择了Cmake，很幸运。这个项目所有依赖的库基本都在项目目录下，跟机器关系不大，cmake不需要写find_lib。源文件不要指定整个目录，一个一个的源文件加进去，修改起来非常方便。 编程习惯折腾了差不多两个周，看了好多代码，不多不说写代码的都是大牛，同时呢，一些问题可能大家常说但是没体会到它的危害，我这次算是深刻体会到了。 命名空间命名空间应该是C++对于C最大的几个亮点之一了。公司前辈们当然也很懂，很多代码都写在了命名空间内。但是一句using namespace ...,全毁了。嗯，改成了A::B::xxx，瞬间心旷神怡。 太长的头文件common头文件和源文件都是典型的长文件。洋洋洒洒近万行的代码，100多行的include简直是一种灾难。相比这个，我想我更喜欢短小、命名准确的文件，哪怕文件数目很多。 成员函数和非成员函数因为项目是处理http请求的，所以有很多从文本解析数据的函数，然后我差不多在每个文件里都看见了处理函数，名字都相差不远。显然，一个类需要从文本中获取数据，所以这个方法就写在了类自身，这样的方法太多就造成可读性极差。更好的方法显然是：将从文本获取数据的方法集中起来，甚至它们不用组合成一个类，只需要把它们放在一个命名空间里就好。 长函数和调用过深这样的代码读起来真的很困难啊。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>编程经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[std::move]]></title>
    <url>%2Fc%2B%2B%2Fmove%2F</url>
    <content type="text"><![CDATA[新特性的目的右值引用 (Rvalue Referene) 是 C++11中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。std::move首先，std::move() 并没有实际移动任何东西。std::move的大致实现： 12345template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) &#123; using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;; return static_cast&lt;ReturnType&gt;(param);&#125; 可以看到： std::move仅仅是进行了类型转换 用std::remove_reference去掉T身上的引用，请看引用折叠。 move的名字其实更接近于rvalue_cast,把值转换为左值。 请不要误解为move接受的参数类型就是右值引用，实际上它是一个通用引用。 避免了不必要的深拷贝。当需要将某个对象的内容“转移”到其他位置时，您可以使用移动，而不进行复制（例如内容不重复，这就是为什么它可以用于某些不可复制的对象，如unique_ptr）。也可以使用std :: move来获取临时对象的内容，而无需复制（并节省大量时间）。它只是向编译器发出信号，程序员不再关心该对象发生了什么。 意义想一下上面的string a(x);想一下下面的场景： x是string类型，而构造x的目的如果仅仅是为了拷贝构造a 构造玩a，x就失去了意义，可以被随意折腾 现在有一个高效的移动构造函数：12345string(string&amp;&amp; that) // rvalue reference&#123; data = that.data; that.data = nullptr;&#125; 那么显然x目前是一个左值（俺有名字），无法match到参数为(string &amp;&amp;x)，到了std::move大显神威的时候了。 功能类型转换：获得一个右值，右值意味着告诉编译器：你可以使用、移动、侵占我所有的资源，因为我只是个右值。 移动构造函数工作是将资源从一个对象移到另一个对象而不是复制它们。复制构造函数会生成深层副本，因为源必须保持不变。另一方面，移动构造函数只能复制指针，然后将源中的指针设置为null。移动对象意味着将其管理的某些资源的所有权转移给另一个对象。想想智能指针。 下面是std::string的可能声明，注意move构造不带const（编译器要把参数掏空无法const） 加了const，就会调用上面的copy构造。12string(const string&amp; rhs); //copy ctorstring(string&amp;&amp; rhs); //move ctor 其他问题 C++11中return local_var与return std::move(local_var)效果是否相同？ 编译器就把优化几乎做到了极致——局部变量返回到函数外部并赋值给外部变量这个过程基本上不存在任何多余的临时变量构造和析构，这比move机制更加高效。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左值、右值和引用]]></title>
    <url>%2Fc%2B%2B%2Flvalue_rvalue%2F</url>
    <content type="text"><![CDATA[左值、右值和引用C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。可以用以下方式理解左值和右值： 左值 左值的定义就是非临时对象，那些可以在多条语句中使用的对象。所有定义的变量都满足这个定义。 一个有用的，有启发意义的判断一个表达式是左值的方法是取它的地址。如果可以取地址，它基本上就是一个左值。如果不行，通常来说是一个右值。（Effective Modern C++）右值 一般没有名字 计算的中间过程，价值只是为了复制到一个有名字的对象。 右值是指临时的对象，它们只在当前的语句中有效。 一般函数返回值是右值。 一些举例123A a1 = GetA(); // a1是左值，GetA()返回的结果是右值int x, y;x+y; // x+y的结果是右值(甚至没有办法叫出名字) 左值引用和右值引用左值引用12int&amp; a = 5; // a是一个左值引用int GetX(int &amp; x); // x算是一个左值引用，虽然它是一个形参 L1 对于上面的GetX函数，显然123int x = 0;int y = Get(x); // okint z = Get(Get(x)) // error，no matching，里面的函数返回的是int &amp;&amp; 右值引用左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。12int &amp;&amp; a = 5; // 右值引用，可以对一个右值引用取地址 L2int GetX(int &amp;&amp; x); 对于上面的GetX函数，也显然1234int x = 0;int y = Get(x); // error，no matching ，x：int &amp;int &amp;&amp; a = 1; // no matterint &amp;&amp; b = x; // error 左值引用和右值引用 对函数的右值引用无论具名与否都将被视为左值 具名右值引用被视为左值，如int &amp; a = 666;，显然，它可以match到int fun(int x); 无名对对象的右值引用被视为x值 对函数的右值引用无论具名与否都将被视为左值,例如：int &amp;&amp; a = 5; int x = 1; int &amp;&amp; b = x;,a和b都可以作为左值。 参数都是左值不管他是一个左值还是一个右值。也就是说，给定一个类型T，你可以得到类型T的左值同时也可以得到它的右值。当处理一个有右值引用的参数时需要铭记于心，因为参数本身是个左值：可以取地址。类似的原因，所有的参数都是左值。实参和形参的区别是很重要的，因为形参只能是左值，但是给他们初始化的实参即有可能是右值也有可能是左值，例：实参std::move(wid)是右值，但是形参wid是左值， 一个抄来的例子123456789101112void process_value(int&amp; i) &#123; std::cout &lt;&lt; "LValue processed: " &lt;&lt; i &lt;&lt; std::endl; &#125; void process_value(int&amp;&amp; i) &#123; std::cout &lt;&lt; "RValue processed: " &lt;&lt; i &lt;&lt; std::endl; &#125; int main() &#123; int a = 0; process_value(a); process_value(1); &#125; 运行结果：12LValue processed: 0 RValue processed: 1 Process_value 函数被重载，分别接受左值和右值。由输出结果可以看出，临时对象是作为右值处理的。 通用引用注意下面这个模板函数12345template&lt;typename T&gt;int fun(T&amp;&amp; x) &#123; // ... return 0;&#125; 注意：T &amp;&amp; 不一定是一个右值引用，他其实是一个通用引用（叫法来自：Effective Modern C++ item24）因为以下调用方式居然都是成立的：1234567// funint x = 1;int y = fun(x);int &amp; a = x;y = fun(a);int &amp;&amp; b = 1;y = fun(b); 编译器推导出了些什么鬼东西，请看引用折叠 引用折叠对于引用有以下消除特性：1234A&amp; &amp; 变成 A&amp;A&amp; &amp;&amp; 变成 A&amp;A&amp;&amp; &amp; 变成 A&amp;A&amp;&amp; &amp;&amp; 变成 A&amp;&amp; 简单结论： 就是左值引用会传染，只有纯右值&amp;&amp; &amp;&amp; = &amp;&amp;，沾上一个左值引用就变左值引用了，根本原因就是：在一处声明为左值，编译器就必须保证此对象可靠（左值）。 引用折叠会出现在4中上下文：模板实例化，auto类型生成，typedef和类型别名声明的创建和使用，decltype。 那么，对于上面的int (T&amp;&amp; x)的几种调用方式就有：123456int x = 1;int y = fun(x); // T被推导为int &amp;，int &amp; &amp;&amp; 折叠为int&amp;int &amp; a = x; // y = fun(a); // T被推导为int &amp;，int &amp; &amp;&amp; 折叠为 int &amp;int &amp;&amp; b = 1;y = fun(b); // T被推导为int，int &amp;&amp;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[More_Effective_C++]]></title>
    <url>%2Fc%2B%2B%2FMore_Effective_C%2B%2B%2F</url>
    <content type="text"><![CDATA[基础指针和引用 指针可以指向空值，可以被重新赋值；引用不可以 存在不指向任何对象的可能，或者需要在不同的时刻指向不同的内容，这个时候用指针。 重载操作符时或者不改变指向的时候，应该使用引用。尽量使用C++的类型转换安全，编译器会帮你检查。不要对数组使用多态 如果函数参数为父类型A，实际传入参数为子类型B，那么编译器不会报错或者警告 但是因为数组每次向后，都跳过一个sizeof(A)，但数组元素实际类型为B，造成越界。 一个具体的例子：数组和多态 避免无用的缺省构造函数 没有默认构造函数的话，B arrb[10]或者B * pb = new B[10] 不能调用构造函数。解决方法：B b[] = {B(1), b(2)...}或者利用指针数组来代替对象数组，即1234567typedef B* pb;pb arrayPb[10]; //不调用构造函数// 或者 pb * arraypb = new pb[10]; // 也不调用构造函数for (int i = 0; i &lt; 10; ++i)&#123; arraypb[i] = new B(i); // 调用构造函数&#125; 上面的第二种方法容易内存泄露。更好的方案是operator new[] 没有默认构造函数的第二个问题：无法在很多基于模板的容器类中使用，要求data = new T[size],当然vector不需要。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用命令]]></title>
    <url>%2Ftools%2Fgit%2F</url>
    <content type="text"><![CDATA[git常用操作生成公钥1ssh-keygen -t rsa 一般公钥存在~/.ssh/id_rsa.pub，并且需要你上传到github，gitlab等。 分支相关 git branch：查看本地有那些分支，结果branch前面带*号的是当前分支。 git branch -a：查看一共有哪些分支：,会列出所有分支，你可以根据分支名拉取分支代码 git checkout -b $branch_name：如果分支不存在，新建一个名字是$branch_name的分支，如果分支存在，拉取分支代码，并切换到分支： 上面的代码也相当于以下两行命令： git branch $branch_name git checkout $branch_name 切换分支：git checkout $branch_name 改完了代码，提交：git commit -m &#39;$text&#39; 提交分支：git push origin [name],如果不加name，会提交所有分支。 删除分支：git branch -d [name] 合并分支：git merge [name]，把分支合并到当前分支/提交merge request 拉取分支的更新：git checkout master;git pull origin,拉取master的更新 查看已经合并了的分支：git branch --merged,这个列表里面不带*的都可以删掉了，因为已经merged 查看未合并的分支：git branch --no-merged,这个不能删除，只能用git branch -D强制删除 显示本地和origin/master分支的diff文件名: git diff origin/master HEAD --name-only 显示本地和origin/master分支的diff: git diff origin/master HEAD tags 查看所有tag：git tag 查看tag详情：git show $tagname 标签必须推送到远程：git push origin --tags 更新到某个tag：git checkout $tagname]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
